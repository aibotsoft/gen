/*
 * Pinnacle - Customer API Reference
 *
 *  # Authentication   API uses HTTP Basic access authentication. You need to send Authorization HTTP Request header:    `Authorization: Basic <Base64 value of UTF-8 encoded \"username:password\">`  Example:  `Authorization: Basic U03MyOT23YbzMDc6d3c3O1DQ1` 
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package pinapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// OddsApiService OddsApi service
type OddsApiService service

type apiOddsSpecialV1GetRequest struct {
	ctx _context.Context
	apiService *OddsApiService
	sportId *int
	oddsFormat *string
	leagueIds *[]int
	since *int64
	specialId *int64
}


func (r apiOddsSpecialV1GetRequest) SportId(sportId int) apiOddsSpecialV1GetRequest {
	r.sportId = &sportId
	return r
}

func (r apiOddsSpecialV1GetRequest) OddsFormat(oddsFormat string) apiOddsSpecialV1GetRequest {
	r.oddsFormat = &oddsFormat
	return r
}

func (r apiOddsSpecialV1GetRequest) LeagueIds(leagueIds []int) apiOddsSpecialV1GetRequest {
	r.leagueIds = &leagueIds
	return r
}

func (r apiOddsSpecialV1GetRequest) Since(since int64) apiOddsSpecialV1GetRequest {
	r.since = &since
	return r
}

func (r apiOddsSpecialV1GetRequest) SpecialId(specialId int64) apiOddsSpecialV1GetRequest {
	r.specialId = &specialId
	return r
}

/*
OddsSpecialV1Get Get Special Odds - v1
Returns odds for specials for all non-settled events.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiOddsSpecialV1GetRequest
*/
func (a *OddsApiService) OddsSpecialV1Get(ctx _context.Context) apiOddsSpecialV1GetRequest {
	return apiOddsSpecialV1GetRequest{
		apiService: a,
		ctx: ctx,
	}
}

/*
Execute executes the request
 @return SpecialOddsResponse
*/
func (r apiOddsSpecialV1GetRequest) Execute() (SpecialOddsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SpecialOddsResponse
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "OddsApiService.OddsSpecialV1Get")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/odds/special"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	if r.sportId == nil {
		return localVarReturnValue, nil, reportError("sportId is required and must be specified")
	}
				
	if r.oddsFormat != nil {
		localVarQueryParams.Add("oddsFormat", parameterToString(*r.oddsFormat, ""))
	}
	localVarQueryParams.Add("sportId", parameterToString(*r.sportId, ""))
	if r.leagueIds != nil {
		t := *r.leagueIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("leagueIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("leagueIds", parameterToString(t, "multi"))
		}
	}
	if r.since != nil {
		localVarQueryParams.Add("since", parameterToString(*r.since, ""))
	}
	if r.specialId != nil {
		localVarQueryParams.Add("specialId", parameterToString(*r.specialId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SpecialOddsResponse
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExtendedErrorResponse
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiOddsStraightV1GetRequest struct {
	ctx _context.Context
	apiService *OddsApiService
	sportId *int
	leagueIds *[]int
	oddsFormat *string
	since *int64
	isLive *bool
	eventIds *[]int64
	toCurrencyCode *string
}


func (r apiOddsStraightV1GetRequest) SportId(sportId int) apiOddsStraightV1GetRequest {
	r.sportId = &sportId
	return r
}

func (r apiOddsStraightV1GetRequest) LeagueIds(leagueIds []int) apiOddsStraightV1GetRequest {
	r.leagueIds = &leagueIds
	return r
}

func (r apiOddsStraightV1GetRequest) OddsFormat(oddsFormat string) apiOddsStraightV1GetRequest {
	r.oddsFormat = &oddsFormat
	return r
}

func (r apiOddsStraightV1GetRequest) Since(since int64) apiOddsStraightV1GetRequest {
	r.since = &since
	return r
}

func (r apiOddsStraightV1GetRequest) IsLive(isLive bool) apiOddsStraightV1GetRequest {
	r.isLive = &isLive
	return r
}

func (r apiOddsStraightV1GetRequest) EventIds(eventIds []int64) apiOddsStraightV1GetRequest {
	r.eventIds = &eventIds
	return r
}

func (r apiOddsStraightV1GetRequest) ToCurrencyCode(toCurrencyCode string) apiOddsStraightV1GetRequest {
	r.toCurrencyCode = &toCurrencyCode
	return r
}

/*
OddsStraightV1Get Get Straight Odds - v1
Returns straight odds for all non-settled events. Please note that it is  possible that the event is in Get Fixtures response but not in Get Odds. This happens when the odds are not currently available for wagering.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiOddsStraightV1GetRequest
*/
func (a *OddsApiService) OddsStraightV1Get(ctx _context.Context) apiOddsStraightV1GetRequest {
	return apiOddsStraightV1GetRequest{
		apiService: a,
		ctx: ctx,
	}
}

/*
Execute executes the request
 @return OddsResponse
*/
func (r apiOddsStraightV1GetRequest) Execute() (OddsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OddsResponse
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "OddsApiService.OddsStraightV1Get")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/odds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	if r.sportId == nil {
		return localVarReturnValue, nil, reportError("sportId is required and must be specified")
	}
						
	localVarQueryParams.Add("sportId", parameterToString(*r.sportId, ""))
	if r.leagueIds != nil {
		t := *r.leagueIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("leagueIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("leagueIds", parameterToString(t, "multi"))
		}
	}
	if r.oddsFormat != nil {
		localVarQueryParams.Add("oddsFormat", parameterToString(*r.oddsFormat, ""))
	}
	if r.since != nil {
		localVarQueryParams.Add("since", parameterToString(*r.since, ""))
	}
	if r.isLive != nil {
		localVarQueryParams.Add("isLive", parameterToString(*r.isLive, ""))
	}
	if r.eventIds != nil {
		t := *r.eventIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("eventIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("eventIds", parameterToString(t, "multi"))
		}
	}
	if r.toCurrencyCode != nil {
		localVarQueryParams.Add("toCurrencyCode", parameterToString(*r.toCurrencyCode, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v OddsResponse
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
